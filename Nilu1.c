/**
 * Задание 10
 * Данная утилита запускает в качестве порожденного процесса
 * программу, указанную в качестве первого аргумента.
 * Остальные аргументы передаются порожденному процессу.
 * Для использования той или иной программы необходимо указать путь
 * до нее.
 * Пример вызова системной ф-и echo:
 * exitcode /bin/echo <то, что хотим вывести>
 * Если нужная программа лежит в той же папке, что и бинарник этой, ее можно запустить, не указывая полный путь
 * exitcode test
 *
 * Компилируется программа так: gcc Nilu1.c -o exitcode
 */
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


/**
 * В качестве параметров ф-и main передается 2 значения.
 * 
 * @argc - количество аргументов программы.
 * Если программа вызвана без аргуметов (например, в консоли ./exitcode) и все, то argc = 1 
 * (не ноль, т.к. само имя программы так же считается аргументом);
 * Если программа вызвана с аргументами - например, ./exitcode /bin/echo hey,
 * то argc = 3.
 *
 * @argv - массив аргументов.
 * Для программы без аргументов (например, пишем в консоли ./exitcode) 
 *     argv[0] = "exitcode"
 * Для программы с аргументами (например, ./exitcode /bin/echo hey)
 *     argv[0] = "exitcode"
 *     argv[1] = "/bin/echo"
 *     argv[2] = "hey"
 * 
 */
int main(int argc, char const *argv[])
{
    /**
     * @status - переменная, которой передается текущее состояние программы.
     * Используя макросы (такие, как WEXITSTATUS()), из нее можно вытащить информацию
     * о состоянии программы и ее атрибутах. В нашем случае - код завершения
     * @ret_val - в нее будет записан код завершения программы (вернее, 8 младших битов кода завершения)
     * @pid - PROCESS ID - идентификатор процесса. Тип pid_t, по сути, соответствует типу unsignet short int, а 
     * такая запись была введена для улучшения читабельности кода.
     * @argv_to_prog - массив аргументов, которые будут переданы порожденному процессу.
     */
    int status = 0, ret_val = -1;
    pid_t pid = 0;

    char **argv_to_prog = argv;
    
    /**
     * argv_to_prog указывает на начало массива с аргументами.
     * Этой операцией мы "сдвинем" этот указатель на 1 элемент вперед.
     * Так мы получем массив аргументов для вызываемой программы.
     */ 
    argv_to_prog += 1;

    /**
     * Если аргументов мало, показываем пользователю, как юзать нашу программу.
     */
    if (argc < 2) {
        printf("USAGE: exitcode <way_to_file> <(no such matter)args>\n");
        return 0;
    }

    /**
     * Делаем системный вызов fork().
     * Он "раздваивает" программу, делает ее клон.
     * В случае вызова pid = fork(), fork() вернет в переменную pid процессу-родителю PID процесса-ребенка, а ребенку - 0.
     * Когда мы делаем форк, по сути, код который находится ниже строки pid = fork(); будет исполнен дважды.
     * 1й раз - в процессе-родителе (основная программа)
     * 2й раз - в процессе ребенке.
     * Эти 2 процесса почти полностью независимы, и переменные у них отделены друг от друга.
     * Т.е.
     * Если у нас есть переменная А = 1, объявленная до форка, то после форка будет 2 А - одна в ребенке, другая в родителе.
     * И если в ребенке поменять А, то в родителе она не поменяется.
     * И наоборот, если в родителе поменять А, в ребенке А будет иметь свое значение.
     *
     * Когда мы делаем форк, у ас наследуется:
     *     локальные и глобальные переменные
     *     используемые библиотеки
     *     таблица дескрипторов
     *     смонтированные файловые системы (подключенные локации на жестком диске/флешке и пр)
     * Не наследуются:
     *     страницы памяти
     *     memory locks
     *     прокинутые указатели
     *     (они указывают на одинаковые области памяти, но не на одну и ту же. Просто на разные копии.)
     *     и прочая лабуда
     */
    pid = fork();

    if (!pid) { /* Аналогично записи if (pid <= 0) */
        /**
         *  Если мы ребенок, то вызываем ф-ю execv()
         *  Он принимает на вход путь к вызываемой программе и массив аргументов для нее.
         *  Функции семейства exec при вызове очищают адресное пространство текущего процесса 
         *  и загружают в него вызываемую программу.
         *  То есть после вызова exec любой код ДЛЯ ДАННОГО ПРОЦЕССА, который написан ниже, НЕ ВЫПОЛНИТСЯ
         *  Как работает exec: он загружает в оперативную память вызываемую программу, затем 
         *  очищает все адресное пространство текущего процесса, а после, с помощью вызова ф-и из семейства mmap
         *  замещает только что очищенное адресное пространство новым, с вызываемой программой.
         */
        execv(argv[1], argv_to_prog);
    } else {
        /**
         * Если мы - родитель, мы ждем завершения всех дочерних процессов (ф-я wait()).
         * Передаем ссылку на объявленную переменную status - в ней будет храниться инфа о состоянии ожидаемых процессов.
         */
        wait(&status);
        /**
         * WEXITSTATUS - макрос ареала ф-и wait().
         * По передаваемой переменной возвращает 8 младших битов возвращаемого значения.
         */
        ret_val = WEXITSTATUS(status);
        printf("Child process successfully returned %d\n", ret_val);
    }
    return 0;
}